// =======================================================
// 1. Base Interface Definition
// =======================================================

/**
 * The primary interface for a User object in the system.
 * This should contain all fields associated with a User.
 */
interface User {
  id: number;
  name: string;
  email: string;
  isAdmin: boolean;
  createdAt: Date;
}

// =======================================================
// 2. The 'typeof' Keyword
// =======================================================

// Example variable (runtime value)
const defaultUser = {
  id: 1,
  name: 'Jane Doe',
  role: 'admin',
};

/**
 * Type inferred from the 'defaultUser' variable's structure.
 * Resulting type: { id: number; name: string; role: string; }
 */
type DefaultUserType = typeof defaultUser;

// =======================================================
// 3. The 'keyof' Operator
// =======================================================

/**
 * Returns a union type of all keys in the User interface.
 * Resulting type: 'id' | 'name' | 'email' | 'isAdmin' | 'createdAt'
 */
type UserKeys = keyof User;

// Example function that uses keyof for type safety
function getProp<T, K extends keyof T>(obj: T, key: K): T[K] {
  // TypeScript is now sure that 'key' is a valid property of 'T'
  return obj[key];
}

const exampleUser: User = {
  id: 2,
  name: 'John Smith',
  email: 'john@example.com',
  isAdmin: false,
  createdAt: new Date(),
};

// This is type-safe:
const userName = getProp(exampleUser, 'name'); // type is string

// This would cause a compile-time error:
// const userAddress = getProp(exampleUser, "address");
// Argument of type '"address"' is not assignable to parameter of type 'UserKeys'.

// =======================================================
// 4. The 'Record' Utility Type
// =======================================================

/**
 * Define a set of roles using a union type.
 */
type UserRole = 'admin' | 'editor' | 'viewer';

/**
 * Creates an object type where keys are from UserRole and values are boolean.
 * Resulting type: { admin: boolean; editor: boolean; viewer: boolean; }
 * This is much cleaner than defining the object manually.
 */
type UserPermissions = Record<UserRole, boolean>;

const access: UserPermissions = {
  admin: true,
  editor: true,
  viewer: false,
};

// =======================================================
// 5. Pick, Omit, and Readonly Utility Types
// =======================================================

/**
 * Pick: Creates a type by selecting specified properties from User.
 * Resulting type includes only 'id' and 'name'. Useful for public profiles.
 */
type PublicUser = Pick<User, 'id' | 'name'>;

/**
 * Omit: Creates a type by omitting specified properties from User.
 * Resulting type includes everything except 'createdAt'.
 */
type UserWithoutTimestamp = Omit<User, 'createdAt'>;

/**
 * Readonly: Makes all properties in the User interface read-only.
 * This is useful for preventing object mutation after creation.
 */
type ImmutableUser = Readonly<User>;

// const immutableUser: ImmutableUser = exampleUser;
// immutableUser.name = "New Name"; // Error: Cannot assign to 'name' because it is a read-only property.

// =======================================================
// 6. NonNullable Utility Type
// =======================================================

type MaybeString = string | null | undefined;

/**
 * NonNullable: Removes 'null' and 'undefined' from a type union.
 * Resulting type: string
 */
type SafeString = NonNullable<MaybeString>;

// =======================================================
// 7. FINAL REFACTOR: Applying Utilities for CRUD Operations
// =======================================================

// -------------------------------------------------------------------
// BAD PRACTICE (before refactor):
// -------------------------------------------------------------------

/*
// Problem: If 'User' changes, these types must be manually updated.

interface CreateUserBad {
  name: string;
  email: string;
  isAdmin: boolean;
}

interface UpdateUserBad {
  id?: number;
  name?: string;
  email?: string;
  isAdmin?: boolean;
  createdAt?: Date;
}
*/

// -------------------------------------------------------------------
// GOOD PRACTICE (The Senior Way):
// -------------------------------------------------------------------

/**
 * CreateUser Type (C in CRUD):
 * Use Omit to remove the ID and createdAt, which are generated by the system.
 */
type CreateUser = Omit<User, 'id' | 'createdAt'>;

/**
 * UpdateUser Type (U in CRUD):
 * Use Partial on the base User to make every field optional.
 * This is perfect for PATCH operations where you only send the fields you want to change.
 */
type UpdateUser = Partial<User>;

// Example usage of the refactored types:

// 1. Create a new user (must provide all non-omitted fields)
const newUser: CreateUser = {
  name: 'Alice Johnson',
  email: 'alice@example.com',
  isAdmin: true,
  // id and createdAt are correctly disallowed here
};

// 2. Update an existing user (fields are optional)
const patchData: UpdateUser = {
  // We only need to provide the fields we are changing
  email: 'alice.new@example.com',
  // All other fields like name, isAdmin, etc., are optional
};

console.log('CreateUser Type:', newUser);
console.log('UpdateUser Patch Data:', patchData);
